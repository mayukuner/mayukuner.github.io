---
layout: post
title: Codeforces Round &#35;333 (Div. 1)
---

前四道水题(虽然第二题犯逗比卡了很长时间)跟最后一题的画风根本不一样好吗...

## 第一题

其实直接分别求只走railway或只走road的1到n的最短路即可.可以证明分别走两条最短路不会出现火车和公交车相撞的情况,因为1到n一定有一条边(railway or road)...

***

## 第二题

类似拉格朗日中值定理,可以证明,一段区间的h一定等于区间中相邻元素的差的绝对值的最大值.可以用栈来维护相邻元素的最大值的作用范围.

***

## 第三题

设$$dp_{i,j}$$为前i场比赛之后,其他选手分数为j的概率,那么$$dp_{i,j}=\frac{\sum_{1 \leq k \leq m 且 k \neq x_i} dp_{i-1,j-k}}{m-1}$$.

记Kleofáš的总得分为$$tot$$,那么最后答案为$$\frac{\sum_{i=1}^{tot-1} dp_{n,i}}{m-1}$$.

m=1时要特判.

***

## 第四题

这不就是字典树合并吗...虽然没写过但是并不难想.

把每棵子树(记其根节点为$$u$$)整理成一个字典树,那么这棵字典树的结点数目就是$$diff(u)$$.先访问$$u$$的儿子结点,将以$$u$$的儿子结点为根的子树都整理成字典树,然后把这些字典树用线段树合并的方法合并就行了.(启发式合并应该也可以.)

***

## 第五题

实际上这是背包问题...如果求得了$$S$$集合的背包数组,然后再加上一个物品$$(v,w)$$求一遍背包,时间复杂度可以达到$$O(k)$$.然而如果想从$$S$$集合删去一个物品$$(v,w)$$后再求背包,就比较困难了.所以我们要把问题转化为添加物品的问题.然后就有了下列做法.

![线段树的思想](http://codeforces.com/predownloaded/85/41/8541f2c820ec7765a2d9f732379912ecee558676.png)

我们把第i个询问的集合记为$$S_i$$.假设有8个询问,那么我们可以先求这8个询问的集合的交的$$dp$$,然后从树根递归下去.每个子节点的$$S$$其实可以由父节点的$$S$$添加若干元素得到,所以每个子节点的$$dp$$数组也可以由父节点的$$dp$$数组通过添加物品重新求$$dp$$数组的方法得到.记3类型的询问的个数为$$qn$$,注意到每个物品最多只能被添加$$O(\log qn)$$次(也就是树高).

实现方法就是:

1. 得到每个物品的有效范围.对于第i个物品,就是一个区间[l_i,r_i],使得$$S_{l_i}..S_{r_i}]$$都包含这个物品.

2. 将每个物品插入从线段树树根插入线段树,如果当前结点所表示的区间在$$[l_i,r_i]$$内,那么就把i放到当前结点的$$S$$中.这样每个物品只会被放到$$O(\log qn)$$个$$S$$中.

3. 自顶向下对线段树的每个节点求$$dp$$数组,但是注意到如果每个结点单开一个数组会MLE,所以只保存当前结点到树根路径上所有结点的$$dp$$数组(也就是当前结点所有祖先的$$dp$$数组),然后把父节点的$$dp$$数组复制到当前结点的$$dp$$数组中,一个一个添加物品,求得当前结点的$$dp$$数组.访问到叶节点时,直接输出答案即可.

<s>目前貌似在CF上execution time最短?</s>

***

代码:

[https://github.com/mayukuner/AC/tree/master/Codeforces/CF333D1](https://github.com/mayukuner/AC/tree/master/Codeforces/CF333D1)
