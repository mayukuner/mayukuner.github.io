---
layout: post
title: Codeforces Round 335 (Div. 1)
---
颓颓颓,四级感觉药丸,线代感觉药丸,颓颓颓...

占坑...

###第一题

赤裸裸暴力.

设$$p_{a_i}=i$$显然,如果按照某个元素为参照位置,那么至少这个元素是不需要移动的.进一步发现,如果选定一个用来参照的元素$$a_i$$,那么不需要移动的元素的个数为包含$$a_i$$的相邻元素间相差1的原数列$${a_n}$$的最长上升子序列
大约就是这样:
{% highlight c++ %}
FOR(i,n){
    if(i>1 && p[i-1]<p[i])
        L[i] = L[i-1] + 1;
    if(i<n && p[i+1]>p[i])
        R[i] = R[i+1] + 1;
}
int ans=1<<30;
FOR(i,n)
    ans = min(ans,n-(L[i]+R[i]+1));
{% endhighlight %}

***

###第二题

赤棵棵构造.

先把整个mst搞成一条每条边的长度单调递减的链.

对于每条mst之外的边$$e$$,找到一条没有使用的点对$$(u,v)$$,使得该点对在mst中的路径上

1. 边的数量大于1,

2. 每条边的长度都小于$$e$$的长度

然后使得$$e$$的两端点变成这个$$(u,v)$$就可以了

***

###第四题

赤裸裸bfs+线段树+set.

最naive的做法,就是对于当前的$$x,y$$以及当前经历的步数$$d$$,找到每一个满足$$a_i \leq x$$而且$$b_i \leq y$$的spell,然后对于每个满足条件的$$spell_i$$,使得$$dis_i=d+1$$,然后把$$i$$放到队列里,下一次迭代到$$i$$时,就要设$$x=c_i,y=d_i$$,然后再进行上述过程.

关键是在于对于一个$$x,y$$,找到满足$$a_i \leq x$$而且$$b_i \leq y$$的所有的点.这一步可以用线段树来做.按离散化后的x坐标(即$$a_i$$)使每个线段树的叶子节点(设其坐标为$$x_0$$)存一个set,储存所有没有遍历到的满足$$a_i=x$$的y坐标$$b_i$$和编号i,然后直接在线段树上查询就可以.查询到之后直接在线段树叶子节点的set中删除这个spell.

***

###第三题

把money视作x,experience视作y,每个job便可表示成一个向量(一个点).在这n个向量外再加上(max_money,0)和(0,max_exp).对这n+2个点求一个上凸壳,显然我们只会用到凸壳上的点.答案便是直线$$qx=py$$与这个凸壳的交点的横坐标除以p(或纵坐标除以q).

太弱不会计算几何,所以直接找到了凸壳上与直线$$qx=py$$有交点的边(记作$$l$$),然后二分答案$$ans$$,当$$(\frac{p}{ans},\frac{q}{ans})$$在凸包内部时,说明ans是可行的.点在$$l$$下方时,说明点在凸包内部.可以用叉积来判断.

***

###第五题

使用dijkstra的思路,记$$dis_i$$为最优情况下从i点到n点所需的时间.到达某个点u之后,我们只会考虑穿越到满足$$dis_v < dis_u$$的v,如果所有这样的v暂时都到达不了,那么我们就在原地等一天,这样结果最优.反过来,我们只需要用$$v$$来更新满足$$dis_u > dis_v$$的点u.然后就可以用跟dijkstra相似的算法.

关键是如何用v去更新u.设$$A_u = \prod_{dis_v < dis_u} (1-p_{u,v}), B_u = \sum_{dis_v < dis_u} (dis_v \prod_{dis_{v_0} < dis_v}(1-p_{u,v_0}))$$,则$$dis_u = A_u dis_u + B_u + 1$$,即$$dis_u = \frac{1-A_u}{B_u+1}$$.
    
代码:[https://github.com/mayukuner/AC/tree/master/Codeforces/CF335D1](https://github.com/mayukuner/AC/tree/master/Codeforces/CF335D1)
